[
  {
    "id": 1,
    "question": "The two commands used in the constructor of a node in a singly linked list Node(int x, Node t) are ____ and ____",
    "type": "short_answer",
    "correctAnswer": "info = x; next = t;",
    "explanation": "In the constructor of a node in a singly linked list, the two basic commands are assigning the value to the node (info = x) and assigning the next pointer to point to the next node (next = t). / Trong hàm tạo một nốt (Node) trong danh sách liên kết đơn, hai lệnh cơ bản là gán giá trị cho nút (info = x) và gán con trỏ next trỏ đến nút tiếp theo (next = t)."
  },
  {
    "id": 2,
    "question": "The linear search algorithm has a complexity of:",
    "type": "short_answer",
    "correctAnswer": "O(n)",
    "explanation": "The linear search algorithm has a time complexity of O(n) because in the worst case, the algorithm must traverse through all n elements of the array to search. / Thuật toán tìm kiếm tuyến tính (Linear Search) có độ phức tạp thời gian là O(n) vì trong trường hợp xấu nhất, thuật toán phải duyệt qua tất cả n phần tử của mảng để tìm kiếm."
  },
  {
    "id": 3,
    "question": "To traverse a tree breadth-first, we use the data structure:",
    "type": "short_answer",
    "correctAnswer": "Queue",
    "explanation": "To traverse a tree breadth-first (Breadth-First Search/Level Order Traversal), we use the Queue data structure. The queue helps store nodes in the order they need to be visited, ensuring nodes at the same level are visited before moving to nodes at the next level. / Để duyệt cây theo chiều rộng (Breadth-First Search/Level Order Traversal), ta sử dụng cấu trúc dữ liệu Hàng đợi (Queue). Hàng đợi giúp lưu trữ các nút theo thứ tự cần thăm, đảm bảo các nút ở cùng một mức được thăm trước khi đi đến các nút ở mức tiếp theo."
  },
  {
    "id": 4,
    "question": "For the inorder traversal algorithm, the command to print the node value will be located at position:",
    "type": "short_answer",
    "correctAnswer": "The command to print the node value will be located between the two recursive calls (left and right).",
    "explanation": "In the inorder traversal algorithm, the order of visiting nodes is: traverse left subtree, visit root node (print value), traverse right subtree. Therefore, the command to print the node value will be located between the two recursive calls to traverse the left and right subtrees. / Trong thuật toán duyệt trung tự (Inorder Traversal), thứ tự thăm các nút là: duyệt cây con trái, thăm nút gốc (in giá trị), duyệt cây con phải. Do đó, dòng lệnh in giá trị nút sẽ nằm ở giữa hai lời gọi đệ quy để duyệt cây con trái và cây con phải."
  },
  {
    "id": 5,
    "question": "The Stack data type has ____ basic operations.",
    "type": "short_answer",
    "correctAnswer": "2",
    "explanation": "The Stack data type has 2 basic operations: push (add element to the top of the stack) and pop (remove element from the top of the stack). / Trên kiểu dữ liệu Ngăn xếp (Stack) có 2 thao tác cơ bản: push (thêm phần tử vào đỉnh ngăn xếp) và pop (lấy phần tử ra khỏi đỉnh ngăn xếp)."
  },
  {
    "id": 6,
    "question": "The Queue data type has _____ basic operations",
    "type": "short_answer",
    "correctAnswer": "2",
    "explanation": "The Queue data type has 2 basic operations: AddQ/Enqueue (add element to the rear of the queue) and RemoveQ/Dequeue (remove element from the front of the queue). / Trên kiểu dữ liệu Hàng đợi (Queue) có 2 thao tác cơ bản: AddQ/Enqueue (thêm phần tử vào cuối hàng đợi) và RemoveQ/Dequeue (lấy phần tử ra khỏi đầu hàng đợi)."
  },
  {
    "id": 7,
    "question": "To print the last node in a non-empty stack, the missing command in the condition of the following code segment is: \n* ..... p=head; \nwhile(_____) \np=p.next; \nSystem.out.print(p);",
    "type": "short_answer",
    "correctAnswer": "p.next != null",
    "explanation": "To traverse to the last node in a linked list, we need to check the condition p.next != null in the while loop. When p.next == null, it means p is pointing to the last node of the list, the loop will stop and we print the value of the last node. / Để duyệt đến nút cuối cùng trong danh sách liên kết, ta cần kiểm tra điều kiện p.next != null trong vòng lặp while. Khi p.next == null, tức là p đã trỏ đến nút cuối cùng của danh sách, vòng lặp sẽ dừng và ta in ra giá trị của nút cuối cùng."
  },
  {
    "id": 8,
    "question": "For the stack data type, the number of operations that can change the number of elements (increase or decrease) in the stack is ____.",
    "type": "short_answer",
    "correctAnswer": "2",
    "explanation": "For the stack data type, there are 2 operations that can change the number of elements: push (add element, increases count) and pop (remove element, decreases count). / Đối với kiểu dữ liệu ngăn xếp (Stack), có 2 thao tác có thể làm thay đổi số phần tử: push (thêm phần tử, làm tăng số lượng) và pop (lấy phần tử ra, làm giảm số lượng)."
  },
  {
    "id": 9,
    "question": "When searching for value x in binary search tree T, if x is smaller than the root value of T, then we will search in the _____ child of T.",
    "type": "short_answer",
    "correctAnswer": "left",
    "explanation": "In a binary search tree (BST), values smaller than the root node's value are located in the left subtree, and values larger than the root node's value are located in the right subtree. Therefore, when searching for value x where x is smaller than the root value of T, we will search in the left subtree of T. / Trong cây nhị phân tìm kiếm (BST), các giá trị nhỏ hơn giá trị của nút gốc sẽ nằm ở cây con trái, và các giá trị lớn hơn giá trị của nút gốc sẽ nằm ở cây con phải. Do đó, khi tìm giá trị x mà x nhỏ hơn giá trị gốc T, ta sẽ chuyển sang tìm ở cây con trái của T."
  },
  {
    "id": 10,
    "question": "When searching for value x=20 in the array [1,2,3,4,5,6,7,8] using binary search method, the number of times the mid value is calculated is:",
    "type": "short_answer",
    "correctAnswer": "4",
    "explanation": "When searching for value x=20 in array [1,2,3,4,5,6,7,8] using binary search:\nIteration 1: mid = (0+7)/2 = 3, arr[3] = 4 < 20, left = mid+1 = 4\nIteration 2: mid = (4+7)/2 = 5, arr[5] = 6 < 20, left = mid+1 = 6\nIteration 3: mid = (6+7)/2 = 6, arr[6] = 7 < 20, left = mid+1 = 7\nIteration 4: mid = (7+7)/2 = 7, arr[7] = 8 < 20, left = mid+1 = 8 > right = 7, end\nSo the number of times mid value is calculated is 4. / Khi tìm kiếm giá trị x=20 trong dãy [1,2,3,4,5,6,7,8] bằng tìm kiếm nhị phân: Lần 1: mid = (0+7)/2 = 3, arr[3] = 4 < 20, left = mid+1 = 4; Lần 2: mid = (4+7)/2 = 5, arr[5] = 6 < 20, left = mid+1 = 6; Lần 3: mid = (6+7)/2 = 6, arr[6] = 7 < 20, left = mid+1 = 7; Lần 4: mid = (7+7)/2 = 7, arr[7] = 8 < 20, left = mid+1 = 8 > right = 7, kết thúc. Vậy số lần tính giá trị mid là 4 lần."
  },
  {
    "id": 11,
    "question": "The postfix expression of a+b/c^h-k is:",
    "type": "short_answer",
    "correctAnswer": "a b c h ^ / + k -",
    "explanation": "Converting infix expression a+b/c^h-k to postfix:\n1. c^h → c h ^\n2. b/(c^h) → b c h ^ /\n3. a+(b/(c^h)) → a b c h ^ / +\n4. (a+b/(c^h))-k → a b c h ^ / + k -\nSo the postfix expression is: a b c h ^ / + k - / Chuyển biểu thức trung tố a+b/c^h-k sang hậu tố: 1. c^h → c h ^; 2. b/(c^h) → b c h ^ /; 3. a+(b/(c^h)) → a b c h ^ / +; 4. (a+b/(c^h))-k → a b c h ^ / + k -. Vậy biểu thức hậu tố là: a b c h ^ / + k -"
  },
  {
    "id": 12,
    "question": "The postfix expression of (a+b)^(p-q)/k is:",
    "type": "short_answer",
    "correctAnswer": "a b + p q - ^ k /",
    "explanation": "Converting infix expression (a+b)^(p-q)/k to postfix:\n1. (a+b) → a b +\n2. (p-q) → p q -\n3. (a+b)^(p-q) → a b + p q - ^\n4. ((a+b)^(p-q))/k → a b + p q - ^ k /\nSo the postfix expression is: a b + p q - ^ k / / Chuyển biểu thức trung tố (a+b)^(p-q)/k sang hậu tố: 1. (a+b) → a b +; 2. (p-q) → p q -; 3. (a+b)^(p-q) → a b + p q - ^; 4. ((a+b)^(p-q))/k → a b + p q - ^ k /. Vậy biểu thức hậu tố là: a b + p q - ^ k /"
  },
  {
    "id": 13,
    "question": "When inserting values [5, 3, 4, 9, 7, 1, 8, 2, 6] into a BST and traversing the tree using inorder traversal algorithm, the result is:",
    "type": "short_answer",
    "correctAnswer": "1, 2, 3, 4, 5, 6, 7, 8, 9",
    "explanation": "When inserting values [5, 3, 4, 9, 7, 1, 8, 2, 6] into a BST, we get a tree with root 5, left subtree containing [3, 1, 4, 2], right subtree containing [9, 7, 8, 6]. Inorder traversal visits nodes in ascending order of values, so the result is: 1, 2, 3, 4, 5, 6, 7, 8, 9. / Khi chèn các giá trị [5, 3, 4, 9, 7, 1, 8, 2, 6] vào cây BST, ta được cây với gốc là 5, cây con trái gồm [3, 1, 4, 2], cây con phải gồm [9, 7, 8, 6]. Duyệt trung tự (inorder) sẽ thăm các nút theo thứ tự tăng dần của giá trị, do đó kết quả là: 1, 2, 3, 4, 5, 6, 7, 8, 9."
  },
  {
    "id": 14,
    "question": "When inserting values [5, 3, 4, 9, 7, 1, 8, 2, 6] into a BST and traversing the tree using postorder traversal algorithm, the result is:",
    "type": "short_answer",
    "correctAnswer": "2, 1, 4, 3, 6, 8, 7, 9, 5",
    "explanation": "When performing postorder traversal on BST with values [5, 3, 4, 9, 7, 1, 8, 2, 6], we visit nodes in order: left subtree → right subtree → root. The postorder traversal result is: 2, 1, 4, 3, 6, 8, 7, 9, 5. / Khi duyệt hậu tự (post-order) cây BST với các giá trị [5, 3, 4, 9, 7, 1, 8, 2, 6], ta thăm các nút theo thứ tự: cây con trái → cây con phải → gốc. Kết quả duyệt hậu tự là: 2, 1, 4, 3, 6, 8, 7, 9, 5."
  },
  {
    "id": 15,
    "question": "When inserting values [5, 3, 4, 9, 7, 1, 8, 2, 6] into a BST and traversing the tree using breadth-first traversal algorithm, the result is:",
    "type": "short_answer",
    "correctAnswer": "5, 3, 9, 1, 4, 7, 2, 6, 8",
    "explanation": "When performing breadth-first traversal (level order traversal) on BST with values [5, 3, 4, 9, 7, 1, 8, 2, 6], we visit nodes level by level from top to bottom, left to right:\nLevel 1: 5\nLevel 2: 3, 9\nLevel 3: 1, 4, 7\nLevel 4: 2, 6, 8\nThe breadth-first traversal result is: 5, 3, 9, 1, 4, 7, 2, 6, 8. / Khi duyệt chiều rộng (level order traversal) cây BST với các giá trị [5, 3, 4, 9, 7, 1, 8, 2, 6], ta thăm các nút theo từng tầng từ trên xuống dưới, từ trái sang phải: Tầng 1: 5; Tầng 2: 3, 9; Tầng 3: 1, 4, 7; Tầng 4: 2, 6, 8. Kết quả duyệt chiều rộng là: 5, 3, 9, 1, 4, 7, 2, 6, 8."
  },
  {
    "id": 16,
    "question": "In the height function of binary tree T, height(TNode T), the missing part of the code when calculating for non-empty tree case is: if(T==null) return 0; else return 1 + _______",
    "type": "short_answer",
    "correctAnswer": "Math.max(height(T.left), height(T.right));",
    "explanation": "In the height function of a binary tree, if the tree is empty (T==null) then the height is 0. If the tree is not empty, the height equals 1 (for the root node) plus the maximum height between the left and right subtrees. Therefore, the missing part is: Math.max(height(T.left), height(T.right)); / Trong hàm tính chiều cao của cây nhị phân, nếu cây rỗng (T==null) thì chiều cao là 0. Nếu cây không rỗng, chiều cao bằng 1 (cho nút gốc) cộng với chiều cao lớn nhất giữa cây con trái và cây con phải. Do đó, phần lệnh còn thiếu là: Math.max(height(T.left), height(T.right));"
  },
  {
    "id": 17,
    "question": "When sorting array [8, 3, 2, 5, 9, 7, 1] using selection sort algorithm, after step 1 the values in the array are:",
    "type": "short_answer",
    "correctAnswer": "[1, 3, 2, 5, 9, 7, 8]",
    "explanation": "Selection Sort algorithm - Step 1:\n- Find the smallest element in the entire array (from position 0 to end) and swap it with the element at the first position (position 0).\n- The smallest element in the array is 1 (at the last position).\n- Swap 1 with 8 (the first element).\nResult after step 1: [1, 3, 2, 5, 9, 7, 8] / Thuật toán sắp xếp chọn (Selection Sort) - Bước 1: Tìm phần tử nhỏ nhất trong toàn dãy (từ vị trí 0 đến cuối) và đổi chỗ với phần tử ở vị trí đầu (vị trí 0). Phần tử nhỏ nhất trong dãy là 1 (ở vị trí cuối cùng). Đổi chỗ 1 với 8 (phần tử đầu tiên). Kết quả sau bước 1: [1, 3, 2, 5, 9, 7, 8]"
  },
  {
    "id": 18,
    "question": "When sorting array [8, 3, 2, 5, 9, 7, 1] using bubble sort algorithm, after step 2 the values in the array are:",
    "type": "short_answer",
    "correctAnswer": "[2, 3, 5, 7, 1, 8, 9]",
    "explanation": "Bubble Sort algorithm:\nStep 1: Compare and swap adjacent pairs from beginning to end of array\n[8, 3, 2, 5, 9, 7, 1] → [3, 2, 5, 8, 7, 1, 9]\nStep 2: Repeat the process but exclude the last element (already in correct position)\n[3, 2, 5, 8, 7, 1, 9] → [2, 3, 5, 7, 1, 8, 9]\nResult after step 2: [2, 3, 5, 7, 1, 8, 9] / Thuật toán sắp xếp nổi bọt (Bubble Sort): Bước 1: So sánh và đổi chỗ các cặp phần tử liên tiếp từ đầu đến cuối dãy [8, 3, 2, 5, 9, 7, 1] → [3, 2, 5, 8, 7, 1, 9]; Bước 2: Lặp lại quá trình trên nhưng không xét phần tử cuối cùng (đã đúng vị trí) [3, 2, 5, 8, 7, 1, 9] → [2, 3, 5, 7, 1, 8, 9]. Kết quả sau bước 2: [2, 3, 5, 7, 1, 8, 9]"
  },
  {
    "id": 19,
    "question": "The number of binary trees that can be created from 3 values (binary tree with 3 nodes) is:",
    "type": "short_answer",
    "correctAnswer": "5",
    "explanation": "The number of different binary trees that can be created from n nodes is calculated using the nth Catalan number: C(n) = (2n)! / (n! * (n+1)!)\nWith n = 3: C(3) = (2*3)! / (3! * 4!) = 6! / (3! * 4!) = 720 / (6 * 24) = 5\nSo the number of different binary trees that can be created from 3 nodes is: 5 / Số cây nhị phân khác nhau có thể tạo từ n nút được tính bằng số Catalan thứ n: C(n) = (2n)! / (n! * (n+1)!) Với n = 3: C(3) = (2*3)! / (3! * 4!) = 6! / (3! * 4!) = 720 / (6 * 24) = 5. Vậy số cây nhị phân khác nhau có thể tạo từ 3 nút là: 5"
  },
  {
    "id": 20,
    "question": "When traversing a tree using postorder traversal algorithm, the command to print the root value is placed at position (1,2,3):",
    "type": "short_answer",
    "correctAnswer": "3",
    "explanation": "In postorder traversal algorithm, the order of visiting nodes is:\n1. Traverse left subtree\n2. Traverse right subtree\n3. Print root value (current node)\nSo the command to print the root value is placed at position 3. / Trong duyệt cây theo thuật toán duyệt hậu tự (post-order traversal), thứ tự thăm các nút là: 1. Duyệt cây con trái; 2. Duyệt cây con phải; 3. In giá trị gốc (nút hiện tại). Vậy lệnh in giá trị gốc được đặt ở vị trí 3."
  },
  {
    "id": 21,
    "question": "For pointer p to point to the end of the list, the missing part in the following while loop is: ....p=head; while(______) p=p.next;",
    "type": "short_answer",
    "correctAnswer": "p.next != null",
    "explanation": "For pointer p to point to the last node of the linked list, we need to traverse the list until p.next == null (meaning p is pointing to the last node). Therefore, the condition in the while loop must be p.next != null. / Để con trỏ p trỏ đến nút cuối cùng của danh sách liên kết, ta cần duyệt danh sách cho đến khi p.next == null (tức là p đã trỏ đến nút cuối). Do đó, điều kiện trong vòng lặp while phải là p.next != null."
  },
  {
    "id": 22,
    "question": "Function int f(int n) is used to count the number of digits of positive integer n. The missing part in the function body below is: ......if(n>0) return 1 + f(_____) ; else return 0;",
    "type": "short_answer",
    "correctAnswer": "n / 10",
    "explanation": "The recursive function f(int n) counts the number of digits of positive integer n by:\n- If n > 0, return 1 (for the last digit) plus the number of digits of n/10 (removing the last digit)\n- If n = 0, return 0\nSo the missing part is: n / 10 / Hàm đệ quy f(int n) đếm số chữ số của số nguyên dương n bằng cách: Nếu n > 0, trả về 1 (cho chữ số cuối cùng) cộng với số chữ số của n/10 (loại bỏ chữ số cuối cùng); Nếu n = 0, trả về 0. Vậy phần lệnh còn thiếu là: n / 10"
  },
  {
    "id": 23,
    "question": "The complexity when multiplying two square matrices of size n is O(n^____)",
    "type": "short_answer",
    "correctAnswer": "3",
    "explanation": "When multiplying two square matrices of size n, we need to perform n^3 multiplication and addition operations (n^2 result elements, each element requires n multiplications and n-1 additions). Therefore, the time complexity is O(n^3). / Khi nhân hai ma trận vuông kích thước n, ta cần thực hiện n^3 phép nhân và cộng (n^2 phần tử kết quả, mỗi phần tử cần n phép nhân và n-1 phép cộng). Do đó, độ phức tạp thời gian là O(n^3)."
  },
  {
    "id": 24,
    "question": "Given the values: 17, 8, 13, 22, 4, 19, 33, 10, 18, 6 inserted into an empty Binary Search Tree (BST), what is the result of a pre-order traversal?",
    "type": "short_answer",
    "correctAnswer": "17, 8, 4, 6, 13, 10, 22, 19, 18, 33",
    "explanation": "When inserting values [17, 8, 13, 22, 4, 19, 33, 10, 18, 6] into an empty BST, we get a tree with root 17. Pre-order traversal visits nodes in order: root → left subtree → right subtree. Result: 17, 8, 4, 6, 13, 10, 22, 19, 18, 33. / Khi chèn các giá trị [17, 8, 13, 22, 4, 19, 33, 10, 18, 6] vào cây BST rỗng, ta được cây với gốc là 17. Duyệt tiền tự (pre-order) thăm các nút theo thứ tự: gốc → cây con trái → cây con phải. Kết quả: 17, 8, 4, 6, 13, 10, 22, 19, 18, 33."
  },
  {
    "id": 25,
    "question": "Given the values: 17, 8, 13, 22, 4, 19, 33, 10, 18, 6 inserted into an empty Binary Search Tree (BST), what is the result of a breadth-first traversal?",
    "type": "short_answer",
    "correctAnswer": "17, 8, 22, 4, 13, 19, 33, 6, 10, 18",
    "explanation": "Breadth-first traversal (level order) visits nodes level by level from top to bottom, left to right:\nLevel 1: 17\nLevel 2: 8, 22\nLevel 3: 4, 13, 19, 33\nLevel 4: 6, 10, 18\nResult: 17, 8, 22, 4, 13, 19, 33, 6, 10, 18. / Duyệt theo chiều rộng (breadth-first/level order) thăm các nút theo từng tầng từ trên xuống dưới, từ trái sang phải: Tầng 1: 17; Tầng 2: 8, 22; Tầng 3: 4, 13, 19, 33; Tầng 4: 6, 10, 18. Kết quả: 17, 8, 22, 4, 13, 19, 33, 6, 10, 18."
  },
  {
    "id": 26,
    "question": "Convert the following infix expression to postfix: P + (Q * R) / (S - T * U)",
    "type": "short_answer",
    "correctAnswer": "P Q R * S T U * - / +",
    "explanation": "Converting infix expression P + (Q * R) / (S - T * U) to postfix:\n1. Q * R → Q R *\n2. T * U → T U *\n3. S - (T * U) → S T U * -\n4. (Q * R) / (S - T * U) → Q R * S T U * - /\n5. P + ((Q * R) / (S - T * U)) → P Q R * S T U * - / +\nSo the result is: P Q R * S T U * - / + / Chuyển đổi biểu thức trung tố P + (Q * R) / (S - T * U) sang hậu tố: 1. Q * R → Q R *; 2. T * U → T U *; 3. S - (T * U) → S T U * -; 4. (Q * R) / (S - T * U) → Q R * S T U * - /; 5. P + ((Q * R) / (S - T * U)) → P Q R * S T U * - / +. Vậy kết quả là: P Q R * S T U * - / +"
  },
  {
    "id": 27,
    "question": "Convert the following infix expression to postfix: A + B * C - D / E",
    "type": "short_answer",
    "correctAnswer": "A B C * + D E / -",
    "explanation": "Converting infix expression A + B * C - D / E to postfix according to operator precedence:\n1. B * C → B C *\n2. A + (B * C) → A B C * +\n3. D / E → D E /\n4. (A + B * C) - (D / E) → A B C * + D E / -\nSo the result is: A B C * + D E / - / Chuyển đổi biểu thức trung tố A + B * C - D / E sang hậu tố theo thứ tự ưu tiên toán tử: 1. B * C → B C *; 2. A + (B * C) → A B C * +; 3. D / E → D E /; 4. (A + B * C) - (D / E) → A B C * + D E / -. Vậy kết quả là: A B C * + D E / -"
  }
]
